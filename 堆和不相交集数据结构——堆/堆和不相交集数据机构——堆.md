#  堆

在很多情况下我们需要使用一种具有 **插入元素** 和 **查找最大值元素** 的数据结构，这种数据结构叫做 **优先队列**
，如果采用普通队列，那么寻找最大元素需要搜索整个队列，开销比较大；如果使用排序数组，插入运算就需要移动很多的元素，开销也会比较大。这时候 **堆**
就是一种 **有效的实现优先队列的数据结构** 。

堆的特点：

  * 父节点大于等于子节点（但是两个子节点之间的大小关系没有要求），这样可以做到 **沿着每条从根节点到叶子节点的路径，元素的键值都是以非升序排列的** 。 
  * 堆是一个 **几乎完全的二叉树** ，所以具有和完全二叉树一样的特点，即一般是存储在一个数组A[n]中，A[i]的左子节点在A[2i]中，右子节点在A[2i+1]中（当他们存在的时候）,A[i]的父亲节点在A[i/2]中（如果存在，i/2向下取整）。 

堆需要支持的几种运算：

    * delete-max[H] 从一个非空的堆H中删除最大元素并将数据项返回 
    * insert[H,x] 将x插入到对H中 
    * delete[H,i] 从堆中删除第i项（注意不是删除i） 
    * makeheap[A] 将A转换成一个堆 

##  堆上的运算

###  两个辅助运算

####  SIFT-DOWN

#####  功能

当某个节点（H[i]）的值大于他的父亲节点的值时，需要通过SITF-UP将这个节点 **沿着从H[i]到H[1]这条唯一的路径**
上移到合适的位置以形成一个合格的堆。

#####  实现思路

将H[i]与其父亲节点H[i/2]比较，如果H[i]大于H[i/2]，则将H[i]与H[i/2]互换，直到H[i]没有父节点或者H[i]不大于H[i/2]。

#####  代码


​    
```c
 int SiftUp(int *H, int i) {

    while (true) {
        if (i == 1) {
            break;//说明当前i是根节点
        }
        if (H[i] > H[(int) i / 2]) {//如果当前节点比父亲节点大
            int t;
            t = H[i];
            H[i] = H[(int) i / 2];
            H[(int) i / 2] = t;
            i = i / 2;
        } else {
            break;
        }
    }
    return 0;
}
```

####  SIFT-DOWN

#####  功能

当某个节点（H[i]，i<=(int)n/2即 **非叶子节点**
）的值小于它的两个子节点H[2i]和H[2i+1]（如果存在的话）的最大值时，需要将SIFT-DOWN将渗到合适的位置。

#####  实现思路

将H[i]与其两个子节点中值最大的元素比较，如果小于最大的那个节点，则将H[i]与其最大的那个子节点互换。

#####  代码：


​    
```c
 int SiftDown(int *H, int i, int n) {
    while (true) {
        i = 2 * i;
        if (i > n) {
            break;
        }

        if (i + 1 <= n) {
            if (H[i + 1] > H[i]) {//比较两个子节点哪个最大
                i++;
            }
        }

        if (H[i] > H[(int) i / 2]) {
            int t;
            t = H[i];
            H[i] = H[(int) i / 2];
            H[(int) i / 2] = t;
        }
    }
}
```

###  插入（insert）

#####  功能

将元素x插入到已有的堆H中

#####  实现思路

首先将堆的大小增加1（n++），然后将x放在H[n]中，然后根据需要将H[n]中的元素x进行上移操作，直到最后形成一个合格的堆。

#####  算法时间复杂度分析

一个大小为n的二叉堆其高度应该为（int）logn，所以将一个元素插入大小为n的堆中所需的时间复杂度为 **O（logn）**

#####  代码


​    
```c
 void insert(int *H,int x,int &n){
    n++;
    //这里默认H开的空间够用
    H[n]=x;
    SiftUp(H, n);//将x根据需要上移
}
```

###  删除（delete）

#####  功能

将堆H中的元素x删除

#####  实现思路

用堆中的最后一个元素H[n]替换需要删除的元素H[i]，然后堆的大小减一（n–），然后根据需要对H[i]进行上移或者下渗直到最后形成一个合格的堆。

#####  算法时间复杂度分析

一个大小为n的二叉堆其高度应该为（int）logn，所以从一个大小为n的堆中将一个元素删除所需的时间复杂度为 **O（logn）**

#####  代码


​    
```c
 void Delete(int *H, int i, int &n) {

    if (i == n) {//如果需要删除的是最后一个元素
        n--;
        return;
    }

    H[i] = H[n];
    n--;

    if (H[i] > H[(int) i / 2]) {//如果当前节点比父亲节点大则需要上移
        SiftUp(H, i);
    } else {//否则进行下渗
        SiftDown(H, i, n);
    }
}
```

###  删除最大值（deletemax）

#####  功能

将堆H中的最大元素x删除并返回最大值。

#####  实现思路

用堆中的最后一个元素H[n]替换需要删除的元素H[1]，然后堆的大小减一（n–），然后根据需要对H[1]进行上移或者下渗直到最后形成一个合格的堆。

#####  算法时间复杂度分析

一个大小为n的二叉堆其高度应该为（int）logn，所以从一个大小为n的堆中将一个元素删除所需的时间复杂度为 **O（logn）**

#####  代码


​    
```c
 int DeleteMax(int *H,int &n){
    int x=H[1];
    Delete(H, 1, n);
    return x;
}
```

###  创建堆（makeheap）

#####  功能

给出一个有n个元素的数组H[1….n]，创建一个包含这些元素的堆。

#####  实现思路

类似于分治，首先，H的叶子节点（即最下面的一层单个元素）可以认为是若干个小堆，然后我们从倒数第二层开始，将倒数第二层和倒数第一层的元素进行适当调整，使得调整之后整个二叉完全数的最后两层是若干个子堆，按照这个思路，依次向上走，最终走到第1层的时候就可以保证整个完全二叉树是一个符合要求的堆。

需要注意的是对于一个完全二叉树， **倒数第二层的最后一个元素的下标为int(n/2)** ，（因为倒数第二层的最后一个节点的下标x应该满足x*2=n）.

#####  算法时间复杂度分析

senta(n)

#####  代码


​    
```c
 void makeheap(int *H,int n){
    for (int i = n/2; i >=1 ; --i) {//从倒数第二层到第一层
        SiftDown(H,i,n);
    }
}
```

###  堆排序（heapsort）

#####  功能

利用堆对数组H[n]进行排序。

#####  实现思路

首先将数组H[n]调整成为一个（大顶）堆，这时可以保证H[1]是数组中的最大元素，然后将H[1]与H[n]互换位置，然后再调整1——n-1为一个大顶堆，然后将H[1]与H[n-1]互换，以此类推，最后就可以保证H为一个非升序的数组。

#####  算法复杂度分析

空间复杂度：因为本算法是在数组H原有的空间基础上进行排序的，所以空间复杂度是Senta（1）。  
时间复杂度：  
\+ 建堆 senta(n)  
\+ 执行n-1次siftdown nlog(n)  
所以总的时间复杂度是nlog（n）

#####  代码


​    
```c
void HeapSort(int *H,int n){
    makeheap(H,n);
    int t;
    for (int i = n; i >=2 ; --i) {
        t=H[i];
        H[i]=H[1];
        H[1]=t;
        SiftDown(H,1,i-1);
    }
}
```

